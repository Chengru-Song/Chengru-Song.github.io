<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="zh-CN" /><updated>2023-01-10T21:13:28+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Chengru’s Blog</title><subtitle>A personal blog website for sharing of technology, reflection and branding. 
</subtitle><author><name>Chengru Song</name></author><entry><title type="html">【阅读】The Tyranny of Merit. 傲慢的精英</title><link href="http://localhost:4000/blog/read/2023/01/10/the-tyranny-of-merit.html" rel="alternate" type="text/html" title="【阅读】The Tyranny of Merit. 傲慢的精英" /><published>2023-01-10T13:41:58+08:00</published><updated>2023-01-10T13:41:58+08:00</updated><id>http://localhost:4000/blog/read/2023/01/10/the-tyranny-of-merit</id><content type="html" xml:base="http://localhost:4000/blog/read/2023/01/10/the-tyranny-of-merit.html"><![CDATA[<h1 id="综述">综述</h1>

<p>interesting，优绩至上理论竟然会带来很大的副作用，而且其中一个甚至和看起来毫不相干的信奉上帝有关。</p>

<p>信奉上帝相信我们做了善行，那么上帝会根据这个善行给予我们奖赏，反之会给我们惩罚。因此当一个人极度不幸的时候，很多人甚至怀疑这个人其实做过一些不为人知的恶行，这加深了对受难者的伤害。</p>

<!--more-->

<p>而且这种思想极度以人为中心，上帝大部分时间都在回应人类的行为。因此，即使是在上帝面前，我们也是在争取赢得自己的命运，这又是一层优绩主义带来的伤害。</p>

<p>这是美国人写的书，这本书分别讨论了在历史中优绩主义的提现和现代优绩主义的提现。在历史中，这种优绩主义在信奉善有善报恶有恶报的人中有更为明显的体现。现代略有不同，现代美国经常主张自己的“美国梦”，每个人都能通过努力实现阶级跃迁，文凭也逐渐成为了大家最后能接受的偏见，即拥有更好学历的人是通过自己的努力实现的跨越，因此他们可以接受自己成为社会的精英并享受这种文凭给自己带来的优待。虽然实际上当前已经有非常多的人在表达精英统治的不满。而很多人也表达了希望大学文凭成为一个分类机器的观点。</p>

<h1 id="分类机器">分类机器</h1>

<p>大学作为分类机器，赞同这个观点的人基本上都认同，不同大学教授的课程的质量本身并不具有在未来具有区分度，而进入这个大学本身，即获取大学的文凭，是具有区分度的。</p>

<p>当然，作者也是非常义正言辞的阐明了以此功用的大学文凭的不公平性。考虑到真实数字就是收入来自全美前1%的家庭占据了常青藤高校超过50%的名额，如果再去考虑这里面的深层逻辑，在美国有非常多的学生是通过捐款进入学校的，还有通过运动员身份进入学校的，这些运动往往都是高尔夫，赛艇，马术等运动，这些运动本身也是平常家庭很难负担的。同时看似平等的SAT，或者中国的高考，以一个分数作为分类标准的，同样非常具有不公平性。富人家庭的孩子能够在大学前教育花费超额的金钱进行培训，甚至是残疾人认证等，来获得不同程度的录取优惠。这同时也会加剧他们的傲慢—我是学习成绩好，智商高来到了这样的地方，这与我的家庭无关。但这同时也会让他们更加不快乐，因为相比于满足自己的求知欲而言，获得更高的分数是更重要的。</p>

<p>综合我看到的另一篇文章，一些具有相当高智商水平的人进入到一些无关紧要，与其本身具有的智商水平并不匹配的岗位时，我认为这有可能是有意而为之。愚民，让聪明人做无关紧要的事，让他们脱离社会，沉浸在自己的世界里，可能是统治者的手段之一。作者讨论的东西当然是很好的，公平是一个天然具有吸引力的词，它让人神往，因此公平意味着可以相信自己。但位置不同，往往看到的公平不同，一个奋斗一生并取得一定成就的人，往往不希望让自己的成就只在当代，他希望延续。这是一个根植于深处的想法，不这么想的人往往是异类。为自己的后台创造良好的生存环境，是一个我在自然界也可以看到的现象，我认为这是一种兽性，是一种原始的欲望，而克制原始的欲望是一件非常难的事情。当你有机会作为规则的制定者，但是你制定的规则，并不会为你带来丝毫的便利，我认为这并不现实。因此尽管我们知道问题的弊端在哪里，但每一个走上那个位置的人都没有做出那样的选择，即使做出了，也很难在延续下去。</p>

<p>那么在这种情况下，到底什么是好的，什么是能够让社会变好的呢？</p>

<h1 id="给工作以尊严">给工作以尊严</h1>

<p>对于不同的工作，我们很容易，甚至于是习惯于，给其分出三六九等。社会对于不同工作是有偏见的，例如水管工、农民工等，他们的工作是没有任何尊严的。有一个解决办法是不以优秀与否来赋予一份工作尊严，而是在道德标准上看这份工作对社会的贡献。例如清洁工，他们的存在让瘟疫的蔓延更加困难，因此当我们从道德角度来评判这一份工作，是应当对其付出更多认可与尊重的。</p>

<p>尽管我十分认同作者说的内容，但我想站位的不同带来了很多执行上阻力。对于能够制定政策的人来说，他们的目标真的是让社会变得更好，每个人都有过得体面的权利吗？虽然大家都声称自己执政的目标是这个，但社会资源的总量是有限的，普通人分到了更多，就意味着这些需要从富人嘴里吐出来。这一套价值观很难真的在当前社会运行，除非物质资源真的极大丰富。但这个条件也许是一个错误假设，因为总可以引导出一些稀缺而我们又看重的资源，存在于这个社会，这样我们就能付出自己非常多的东西来得到这个资源，而这个资源的稀缺性正是人为营造的，例如中国的房地产。没有了房地产可能变成了农产品，汽车，凡是可以带来垄断且必须的产业，都可以被人为弄成稀缺资源，并一茬一茬割韭菜，直到这个社会，人成了稀缺资源，再也没有为上层提供营养的新鲜血液，这时努力活下来的人们才有了资源重新分配机会。作者不喜欢说资源重新分配，因为每个人获得的不是资源，而是对社会的贡献和他人对这份贡献的认可。这种认可会更加合理的分配这些资源。</p>

<h1 id="写在最后">写在最后</h1>

<p>作者提出了一些很好的想法，但对于普通人而言，他们目前的最优策略仍然是想尽办法成为这个体系的优绩者，就像上一本书说的，如果你不能改变游戏规则，那最好加入一个每个人都倾向于在这个规则下正常竞争的游戏。</p>]]></content><author><name>Chengru Song</name></author><category term="[&quot;Blog&quot;, &quot;Read&quot;]" /><category term="301-life-blog" /><summary type="html"><![CDATA[综述 interesting，优绩至上理论竟然会带来很大的副作用，而且其中一个甚至和看起来毫不相干的信奉上帝有关。 信奉上帝相信我们做了善行，那么上帝会根据这个善行给予我们奖赏，反之会给我们惩罚。因此当一个人极度不幸的时候，很多人甚至怀疑这个人其实做过一些不为人知的恶行，这加深了对受难者的伤害。]]></summary></entry><entry><title type="html">【阅读】kknmd house</title><link href="http://localhost:4000/blog/read/2023/01/06/house.html" rel="alternate" type="text/html" title="【阅读】kknmd house" /><published>2023-01-06T13:41:58+08:00</published><updated>2023-01-06T13:41:58+08:00</updated><id>http://localhost:4000/blog/read/2023/01/06/house</id><content type="html" xml:base="http://localhost:4000/blog/read/2023/01/06/house.html"><![CDATA[<h1 id="kk关于房价的思考">KK关于房价的思考</h1>

<p>洞见事务背后的运行逻辑，是预测未来发展的重要因素。如果希望自己有一定的预测能力，需要对以下几点进行加强</p>

<ol>
  <li>掌握足够优质的信息来源；</li>
  <li>对经济运行有较为充足的知识储备；</li>
  <li>对历史的发展规律及其背后的原因有足够的了解；</li>
  <li>基于这些了解能够产出action items。</li>
</ol>

<h2 id="一些摘抄">一些摘抄</h2>

<p>关于房产投资的方向，也有几点心得：供大家参考：</p>

<p>一、坚决不能投资自己不熟悉的城市</p>

<p>二、坚决不投资中小城市，一般省会及计划单列以上城市问题都不大，但中小城市即使房价上涨也存在变现困难问题。</p>

<p>三、坚决不投资距离大城市较偏远的旅游城市，比如山东乳山之类的，几乎无法变现。</p>

<p>四、慎重投资大城市的郊区，除非价格绝对低。如果外来人口比较多，zf又有发展规划，且价格与城区相比有较大的价差，才可以考虑</p>]]></content><author><name>Chengru Song</name></author><category term="[&quot;Blog&quot;, &quot;Read&quot;]" /><category term="301-life-blog" /><summary type="html"><![CDATA[KK关于房价的思考 洞见事务背后的运行逻辑，是预测未来发展的重要因素。如果希望自己有一定的预测能力，需要对以下几点进行加强 掌握足够优质的信息来源； 对经济运行有较为充足的知识储备； 对历史的发展规律及其背后的原因有足够的了解； 基于这些了解能够产出action items。 一些摘抄 关于房产投资的方向，也有几点心得：供大家参考： 一、坚决不能投资自己不熟悉的城市 二、坚决不投资中小城市，一般省会及计划单列以上城市问题都不大，但中小城市即使房价上涨也存在变现困难问题。 三、坚决不投资距离大城市较偏远的旅游城市，比如山东乳山之类的，几乎无法变现。 四、慎重投资大城市的郊区，除非价格绝对低。如果外来人口比较多，zf又有发展规划，且价格与城区相比有较大的价差，才可以考虑]]></summary></entry><entry><title type="html">【Basics】Graphx</title><link href="http://localhost:4000/work/basics/2023/01/04/graphx.html" rel="alternate" type="text/html" title="【Basics】Graphx" /><published>2023-01-04T11:44:07+08:00</published><updated>2023-01-04T11:44:07+08:00</updated><id>http://localhost:4000/work/basics/2023/01/04/graphx</id><content type="html" xml:base="http://localhost:4000/work/basics/2023/01/04/graphx.html"><![CDATA[<h1 id="reference">Reference</h1>

<ol>
  <li>
    <table>
      <tbody>
        <tr>
          <td>Graphx pregel code example: [Processing Hierarchical Data using Spark Graphx Pregel API</td>
          <td>Qubole](https://www.qubole.com/blog/processing-hierarchical-data-using-spark-graphx-pregel-api)</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>graphx official pregel api: <a href="https://spark.apache.org/docs/latest/graphx-programming-guide.html#pregel-api">GraphX - Spark 3.3.1 Documentation (apache.org)</a></li>
  <li></li>
</ol>]]></content><author><name>Chengru Song</name></author><category term="[&quot;work&quot;, &quot;basics&quot;]" /><category term="301-work-blog" /><category term="301-work-learning" /><summary type="html"><![CDATA[Reference Graphx pregel code example: [Processing Hierarchical Data using Spark Graphx Pregel API Qubole](https://www.qubole.com/blog/processing-hierarchical-data-using-spark-graphx-pregel-api) graphx official pregel api: GraphX - Spark 3.3.1 Documentation (apache.org)]]></summary></entry><entry><title type="html">【阅读】Algorithms to Live By</title><link href="http://localhost:4000/blog/read/2022/12/31/algorithms-to-live-by.md.html" rel="alternate" type="text/html" title="【阅读】Algorithms to Live By" /><published>2022-12-31T13:41:58+08:00</published><updated>2022-12-31T13:41:58+08:00</updated><id>http://localhost:4000/blog/read/2022/12/31/algorithms-to-live-by.md</id><content type="html" xml:base="http://localhost:4000/blog/read/2022/12/31/algorithms-to-live-by.md.html"><![CDATA[<h1 id="algorithms-to-live-by">Algorithms to live by</h1>

<p>我觉得很多人应该更熟悉这本书的中文译名，算法之美。看到了微信读书上对于这个译名的评价：为了追求所谓的“信达雅”而没有正确翻译出题目想表达的主题，乍一看还以为是讲算法的，实际上是讲算法在日常生活中的应用的。并且后半部分的翻译好像是为了赶工，看上去并没有针对中国人的表达习惯进行优化，非常像是机翻的，这就导致了后面几章的内容读起来比较晦涩。因此为了避免这个情况，我直接选择读原版的英文版。这反而对于我比较友好，因为上学学算法的时候就是英文教材，很多argot是可以直接代入和理解的，比阅读中文版更能让我理解作者表达的原意。</p>

<p>Regardless of that，这本书讲的还是非常好的。通过算法引申到哪些现实问题其实是这个算法的真实映射，而如果算法本身能够提供解决问题的最优解，那么我们同样可以把这个策略用到我们的生活当中。</p>

<h2 id="abstract">Abstract</h2>

<p>This book is all about introducing how you can apply algorithms to your daily life decisions to make your life easier.</p>

<h2 id="optimal-stopping">Optimal stopping</h2>

<p>“the optimal solution takes the form of what we’ll call the <strong>Look-Then-Leap Rule:</strong> You set a predetermined amount of time for “looking”—that is, exploring your options, gathering data—in which you categorically don’t choose anyone, no matter how impressive. After that point, you enter the “leap” phase, prepared to instantly commit to anyone who outshines the best applicant you saw in the look phase.”</p>

<p><img src="/assets/images/image-20230107160653033.png" alt="image-20230107160653033" /></p>

<p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/121ad852-5f33-4902-906d-8fd544e34380/8E109C18-FA7C-4FE3-A717-CCE2B943AEA8.png" alt="8E109C18-FA7C-4FE3-A717-CCE2B943AEA8.png" /></p>

<p>This principle applies to any situation where you get a series of offers and pay a cost to seek or wait for the next.</p>

<h2 id="exploreexploit">Explore/exploit</h2>

<p>A situation where you don’t know which restaurant to go to, the existing known good or undiscovered ones.</p>

<p>一个简单的策略</p>

<p><strong>Win-Stay, Lose-Shift algorithm</strong>: choose an arm at random, and keep pulling it as long as it keeps paying off. If the arm doesn’t pay off after a particular pull, then switch to the other one. Although this simple strategy is far from a complete solution, Robbins proved in 1952 that it performs reliably better than chance.</p>

<h2 id="the-gittins-index">The Gittins index</h2>

<p>假设每次探索成功后，得到结果满意程度是上次的90%。那么就会有下面这张表。</p>

<p><img src="/assets/images/image-20230107160711255.png" alt="image-20230107160711255" /></p>

<h2 id="cache">cache</h2>

<p>Cache在生活中会有一些可以优化工作流的场景，比如电脑桌面程序和网页，保留哪些，关掉哪些。哪些是可以保存在收藏夹的，哪些是可以不在收藏夹但是可以通过两个动作打开的。</p>

<p>这么看的话可以把收藏夹问题抽象成一个多级缓存问题。对于这个处理原则可以是</p>

<ol>
  <li>哪些是最经常打开的？</li>
  <li>哪些频率略低，可以花时间寻找的？</li>
  <li>哪些可以直接放到文档里面，用到了再去找文档的？</li>
</ol>

<p>First, when you are deciding what to keep and what to throw away, LRU is potentially a good principle to use</p>

<p>“Second, exploit geography. Make sure things are in whatever cache is closest to the place where they’re typically used.”</p>

<p>难以想象，其实社会对于事件的遗忘程度也是一个艾宾浩斯曲线。</p>

<h2 id="scheduling">Scheduling</h2>

<p><strong>基本概念</strong></p>

<ol>
  <li>DDL优先：当你的事情没有重要性排序的时候，你只需要将每一个事情按照到达次序处理，找到快要DDL的事情来做就行。</li>
  <li>Thrashing，当你的事情有优先级排序的时候，很多事情又同时在做，就会崩溃，你发现其实一直在做context swtich，最后其实什么也没做，在外界看来，这样甚至成了拖延症。</li>
  <li>最小时间分片。操作系统实际上有个最小分片，小于这个分片，系统除了不断做context swtich，什么计算任务也无法完成，所以这个最小时间分片是无法继续分割的，必须做完才能做另一个任务。</li>
</ol>

<p><strong>Takeaway</strong></p>

<ol>
  <li>确定自己的最小处理时间分片。在一个分片内，尽量只做一件事。“The moral is that you should try to stay on a single task as long as possible without decreasing your responsiveness below the minimum acceptable limit.”</li>
  <li>Interrupt coalesce. 把给你的中断尽可能合并，比如统一回复邮件。</li>
  <li>对于概念2，可以随机处理事情，而不需要一直卡着优先级排序处理，否则在计算优先级这里又需要花很多时间。</li>
</ol>

<h2 id="bayes-rule">Bayes Rule</h2>

<ol>
  <li>How to predict the probabilities if it happens only once?
    <ol>
      <li>“Count the number of times it has happened in the past plus one, then divide by the number of opportunities plus two. ” da</li>
    </ol>
  </li>
</ol>

<p>人们总是会对最近发生的事情记忆更深，因此，往往会给最近的事情加更多的权重，这会让本来有可能预测准的事情不准。因此要谨慎对待类似的事情。</p>

<h2 id="overfitting">Overfitting</h2>

<p>顾名思义，这章基本上就是在讲，如何能通过正则化，噪声等来避免过拟合带来的影响。</p>

<p>“how early to stop depends on the gap between what you can measure and what really matters.”</p>

<h2 id="relaxation">Relaxation</h2>

<p>这章有个很有意思的观点，relaxation在数学里面的典型代表就是Lagrangian方法，把所有的constraints都当成优化函数的一部分，成为一个新的函数。即利用限制条件来修正优化函数，通过限制条件的最终数值，求得参数值，就能得到原函数的最优解。</p>

<p>类似的事情就是在生活中，我们面对很多选择的时候会受到很多限制条件的束缚。例如必须要工资在多少以上的，工作的位置必须在什么地方，等等。但如果目标是最合适自己的工作，就可以问自己，如果所有工作的工资都一样，我会选择什么？</p>

<p>实际上，在很多时候一个合适的放缩能找到的答案就是最优解了。</p>

<h2 id="randomness">Randomness</h2>

<p>随机，有时候是解决untractable问题的良药。比方说公私钥机制里面的大整数分解问题，本身找到一个数字是哪两个质数的乘积是一个只能穷举的算法，但是如果你可以接受一些错误率，用一些随机的方法，可以在错误率很小的情况下进行验证。</p>

<h2 id="networking">Networking</h2>

<p>Networking里面的慢启动和拥塞避免算法竟然可以映射到职场里！</p>

<p><img src="/assets/images/image-20230107160731675.png" alt="image-20230107160731675" /></p>

<p>考虑这个拥塞避免算法的本质是什么：在不知道对面capacity的情况下，怎么能快速试出来？</p>

<p>在工作中，作为领导，不知道这个人上限是什么的情况下，怎么能快速试出来？</p>

<p>快速指数级升职，直到他无法做好目前的工作。然后降到当前职级的一半（或者工作负载的一半）然后再线性提升。</p>

<h2 id="game-theory">Game theory</h2>

<p>在博弈论里，有一些假设就是每个人都是理性人，大家会做出在当前对自己局面最好的选择。</p>

<p>尽管比较难以接受，即使我们现在全部都变成自动驾驶，有成熟的算法来帮我们规划，在最好的情况下，堵车只能比现在少$\frac{1}{3}$。</p>

<p>在一些不行的Game里面，无论一个人怎么努力，最好的结局是也只是到达一个这个游戏的均衡点。作者用了黑五商店开门举了例子，以往黑五商场开门时间都是早晨8点。但是突然商场A说自己改成凌晨0点开门，对于其他商场来说，必须也在0点开门，这样才能保证销量。因此所有的商场都在0点开门，而谁也没有多挣到钱。这就是一个bad Game。</p>

<p>因此给我们的启示是</p>

<p>“If changing strategies doesn’t help, you can try to change the game. And if that’s not possible, you can at least exercise some control about which games you choose to play. The road to hell is paved with intractable recursions, bad equilibria, and information cascades. Seek out games where honesty is the dominant strategy. Then just be yourself.”</p>]]></content><author><name>Chengru Song</name></author><category term="[&quot;Blog&quot;, &quot;Read&quot;]" /><category term="301-life-blog" /><summary type="html"><![CDATA[Algorithms to live by 我觉得很多人应该更熟悉这本书的中文译名，算法之美。看到了微信读书上对于这个译名的评价：为了追求所谓的“信达雅”而没有正确翻译出题目想表达的主题，乍一看还以为是讲算法的，实际上是讲算法在日常生活中的应用的。并且后半部分的翻译好像是为了赶工，看上去并没有针对中国人的表达习惯进行优化，非常像是机翻的，这就导致了后面几章的内容读起来比较晦涩。因此为了避免这个情况，我直接选择读原版的英文版。这反而对于我比较友好，因为上学学算法的时候就是英文教材，很多argot是可以直接代入和理解的，比阅读中文版更能让我理解作者表达的原意。 Regardless of that，这本书讲的还是非常好的。通过算法引申到哪些现实问题其实是这个算法的真实映射，而如果算法本身能够提供解决问题的最优解，那么我们同样可以把这个策略用到我们的生活当中。 Abstract This book is all about introducing how you can apply algorithms to your daily life decisions to make your life easier. Optimal stopping “the optimal solution takes the form of what we’ll call the Look-Then-Leap Rule: You set a predetermined amount of time for “looking”—that is, exploring your options, gathering data—in which you categorically don’t choose anyone, no matter how impressive. After that point, you enter the “leap” phase, prepared to instantly commit to anyone who outshines the best applicant you saw in the look phase.” This principle applies to any situation where you get a series of offers and pay a cost to seek or wait for the next. Explore/exploit A situation where you don’t know which restaurant to go to, the existing known good or undiscovered ones. 一个简单的策略 Win-Stay, Lose-Shift algorithm: choose an arm at random, and keep pulling it as long as it keeps paying off. If the arm doesn’t pay off after a particular pull, then switch to the other one. Although this simple strategy is far from a complete solution, Robbins proved in 1952 that it performs reliably better than chance. The Gittins index 假设每次探索成功后，得到结果满意程度是上次的90%。那么就会有下面这张表。 cache Cache在生活中会有一些可以优化工作流的场景，比如电脑桌面程序和网页，保留哪些，关掉哪些。哪些是可以保存在收藏夹的，哪些是可以不在收藏夹但是可以通过两个动作打开的。 这么看的话可以把收藏夹问题抽象成一个多级缓存问题。对于这个处理原则可以是 哪些是最经常打开的？ 哪些频率略低，可以花时间寻找的？ 哪些可以直接放到文档里面，用到了再去找文档的？ First, when you are deciding what to keep and what to throw away, LRU is potentially a good principle to use “Second, exploit geography. Make sure things are in whatever cache is closest to the place where they’re typically used.” 难以想象，其实社会对于事件的遗忘程度也是一个艾宾浩斯曲线。 Scheduling 基本概念 DDL优先：当你的事情没有重要性排序的时候，你只需要将每一个事情按照到达次序处理，找到快要DDL的事情来做就行。 Thrashing，当你的事情有优先级排序的时候，很多事情又同时在做，就会崩溃，你发现其实一直在做context swtich，最后其实什么也没做，在外界看来，这样甚至成了拖延症。 最小时间分片。操作系统实际上有个最小分片，小于这个分片，系统除了不断做context swtich，什么计算任务也无法完成，所以这个最小时间分片是无法继续分割的，必须做完才能做另一个任务。 Takeaway 确定自己的最小处理时间分片。在一个分片内，尽量只做一件事。“The moral is that you should try to stay on a single task as long as possible without decreasing your responsiveness below the minimum acceptable limit.” Interrupt coalesce. 把给你的中断尽可能合并，比如统一回复邮件。 对于概念2，可以随机处理事情，而不需要一直卡着优先级排序处理，否则在计算优先级这里又需要花很多时间。 Bayes Rule How to predict the probabilities if it happens only once? “Count the number of times it has happened in the past plus one, then divide by the number of opportunities plus two. ” da 人们总是会对最近发生的事情记忆更深，因此，往往会给最近的事情加更多的权重，这会让本来有可能预测准的事情不准。因此要谨慎对待类似的事情。 Overfitting 顾名思义，这章基本上就是在讲，如何能通过正则化，噪声等来避免过拟合带来的影响。 “how early to stop depends on the gap between what you can measure and what really matters.” Relaxation 这章有个很有意思的观点，relaxation在数学里面的典型代表就是Lagrangian方法，把所有的constraints都当成优化函数的一部分，成为一个新的函数。即利用限制条件来修正优化函数，通过限制条件的最终数值，求得参数值，就能得到原函数的最优解。 类似的事情就是在生活中，我们面对很多选择的时候会受到很多限制条件的束缚。例如必须要工资在多少以上的，工作的位置必须在什么地方，等等。但如果目标是最合适自己的工作，就可以问自己，如果所有工作的工资都一样，我会选择什么？ 实际上，在很多时候一个合适的放缩能找到的答案就是最优解了。 Randomness 随机，有时候是解决untractable问题的良药。比方说公私钥机制里面的大整数分解问题，本身找到一个数字是哪两个质数的乘积是一个只能穷举的算法，但是如果你可以接受一些错误率，用一些随机的方法，可以在错误率很小的情况下进行验证。 Networking Networking里面的慢启动和拥塞避免算法竟然可以映射到职场里！ 考虑这个拥塞避免算法的本质是什么：在不知道对面capacity的情况下，怎么能快速试出来？ 在工作中，作为领导，不知道这个人上限是什么的情况下，怎么能快速试出来？ 快速指数级升职，直到他无法做好目前的工作。然后降到当前职级的一半（或者工作负载的一半）然后再线性提升。 Game theory 在博弈论里，有一些假设就是每个人都是理性人，大家会做出在当前对自己局面最好的选择。 尽管比较难以接受，即使我们现在全部都变成自动驾驶，有成熟的算法来帮我们规划，在最好的情况下，堵车只能比现在少$\frac{1}{3}$。 在一些不行的Game里面，无论一个人怎么努力，最好的结局是也只是到达一个这个游戏的均衡点。作者用了黑五商店开门举了例子，以往黑五商场开门时间都是早晨8点。但是突然商场A说自己改成凌晨0点开门，对于其他商场来说，必须也在0点开门，这样才能保证销量。因此所有的商场都在0点开门，而谁也没有多挣到钱。这就是一个bad Game。 因此给我们的启示是 “If changing strategies doesn’t help, you can try to change the game. And if that’s not possible, you can at least exercise some control about which games you choose to play. The road to hell is paved with intractable recursions, bad equilibria, and information cascades. Seek out games where honesty is the dominant strategy. Then just be yourself.”]]></summary></entry><entry><title type="html">【Blog】年度回顾</title><link href="http://localhost:4000/life/blog/2022/12/31/past-year-reflection.html" rel="alternate" type="text/html" title="【Blog】年度回顾" /><published>2022-12-31T11:44:07+08:00</published><updated>2022-12-31T11:44:07+08:00</updated><id>http://localhost:4000/life/blog/2022/12/31/past-year-reflection</id><content type="html" xml:base="http://localhost:4000/life/blog/2022/12/31/past-year-reflection.html"><![CDATA[]]></content><author><name>Chengru Song</name></author><category term="[&quot;life&quot;, &quot;Blog&quot;]" /><category term="301-life-blog" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">【Basics】Functional Programming</title><link href="http://localhost:4000/work/basics/2022/12/26/functional-programming.html" rel="alternate" type="text/html" title="【Basics】Functional Programming" /><published>2022-12-26T11:44:07+08:00</published><updated>2022-12-26T11:44:07+08:00</updated><id>http://localhost:4000/work/basics/2022/12/26/functional-programming</id><content type="html" xml:base="http://localhost:4000/work/basics/2022/12/26/functional-programming.html"><![CDATA[<h1 id="functional-programming">Functional Programming</h1>

<p>What’s the novelty of functional programming?</p>

<p><a href="https://www.zhihu.com/question/28292740/answer/40336090">什么是函数式编程思维？ - 用心阁的回答 - 知乎</a></p>

<p><em>Functional Programming</em>通过建立映射的方式获取新的结果，因此是stateless的。想象成，数据流过一个个函数组成的管道，然后变成了另一个值。这是一个基本思想，实际编程的时候，就是返回新的object而不是经过改变的变量。</p>

<h2 id="materials">Materials</h2>

<ol>
  <li><a href="https://github.com/hemanth/functional-programming-jargon">Functional Programming Jargon</a></li>
  <li></li>
</ol>]]></content><author><name>Chengru Song</name></author><category term="[&quot;work&quot;, &quot;basics&quot;]" /><category term="301-work-blog" /><category term="301-work-learning" /><summary type="html"><![CDATA[Functional Programming What’s the novelty of functional programming? 什么是函数式编程思维？ - 用心阁的回答 - 知乎 Functional Programming通过建立映射的方式获取新的结果，因此是stateless的。想象成，数据流过一个个函数组成的管道，然后变成了另一个值。这是一个基本思想，实际编程的时候，就是返回新的object而不是经过改变的变量。 Materials Functional Programming Jargon]]></summary></entry><entry><title type="html">【Big-Data】Scala</title><link href="http://localhost:4000/work/scala/2022/12/23/scala.html" rel="alternate" type="text/html" title="【Big-Data】Scala" /><published>2022-12-23T16:18:07+08:00</published><updated>2022-12-23T16:18:07+08:00</updated><id>http://localhost:4000/work/scala/2022/12/23/scala</id><content type="html" xml:base="http://localhost:4000/work/scala/2022/12/23/scala.html"><![CDATA[<h1 id="scala-basics">Scala Basics</h1>

<h2 id="learning-materials">Learning Materials</h2>

<ol>
  <li><a href="https://github.com/Baeldung/scala-tutorials/tree/master/scala-core-7">scala core</a></li>
  <li><a href="https://boringml.com/docs/platforms/spark/testing-dataframes/">scala spark unit test</a></li>
  <li>scala underscore explained: <a href="https://www.jianshu.com/p/d271afce8c71">Scala中下划线“_”的用法小结 - 简书 (jianshu.com)</a></li>
</ol>

<h2 id="how-to-create-a-maven-scala-project">How to create a maven scala project</h2>

<h3 id="using-idea">Using Idea</h3>

<p>archetype</p>

<p><code class="language-plaintext highlighter-rouge">net.alchim31.maven:scala-archetype-simple</code></p>

<p><img src="/assets/images/image-20221223163937001.png" alt="image-20221223163937001" /></p>

<h2 id="project-dependency">Project dependency</h2>

<p>Reference</p>

<p><a href="https://george-jen.gitbook.io/data-science-and-apache-spark/spark-and-scala-version">spark version v.s. scala version</a></p>

<blockquote>
  <p>Any version of Spark requries a specific version Scala.  When you build an application to be written Scala, you want to make sure yourScala version is compatible with Spark version you have.</p>
</blockquote>

<p>If you change the dependencies once and the IDE does not agree with what you just did. Right click on <code class="language-plaintext highlighter-rouge">pom.xml</code> and <code class="language-plaintext highlighter-rouge">reimport</code> the whole project. It should be working just fine.</p>

<p><img src="/assets/images/image-20221227151614767.png" alt="image-20221227151614767" /></p>]]></content><author><name>Chengru Song</name></author><category term="[&quot;work&quot;, &quot;scala&quot;]" /><category term="301-work-blog" /><category term="301-work-learning" /><summary type="html"><![CDATA[Scala Basics Learning Materials scala core scala spark unit test scala underscore explained: Scala中下划线“_”的用法小结 - 简书 (jianshu.com) How to create a maven scala project Using Idea archetype net.alchim31.maven:scala-archetype-simple Project dependency Reference spark version v.s. scala version Any version of Spark requries a specific version Scala. When you build an application to be written Scala, you want to make sure yourScala version is compatible with Spark version you have. If you change the dependencies once and the IDE does not agree with what you just did. Right click on pom.xml and reimport the whole project. It should be working just fine.]]></summary></entry><entry><title type="html">【Basics】Git Rebase</title><link href="http://localhost:4000/work/git/2022/12/01/git-rebase.html" rel="alternate" type="text/html" title="【Basics】Git Rebase" /><published>2022-12-01T09:18:07+08:00</published><updated>2022-12-01T09:18:07+08:00</updated><id>http://localhost:4000/work/git/2022/12/01/git-rebase</id><content type="html" xml:base="http://localhost:4000/work/git/2022/12/01/git-rebase.html"><![CDATA[<h1 id="git-rebase">Git rebase</h1>

<h2 id="when-to-use">When to use</h2>

<p>If you want to have a clean git commits history. If six features are being developed in parallel, they starts from different time and they launch in different times. When you need to roll back some features, you will discover that you have diverged from the main so much.</p>

<h2 id="what-is-git-rebase">What is git rebase</h2>

<p><img src="https://resources.jetbrains.com/help/img/idea/2022.2/feature_branch_diagram.png" alt="feature branch" /></p>

<p><img src="https://resources.jetbrains.com/help/img/idea/2022.2/feature_branch_diverge_from_master_diagram.png" alt="feature branch diverged from master" /></p>

<p><img src="https://resources.jetbrains.com/help/img/idea/2022.2/rebase_result_diagram.png" alt="rebase operation result" /></p>

<p>When you merge a branch, step 3 will actually look like this:</p>

<p><img src="https://resources.jetbrains.com/help/img/idea/2022.2/merge_result_diagram.png" alt="merge result" /></p>]]></content><author><name>Chengru Song</name></author><category term="[&quot;work&quot;, &quot;git&quot;]" /><category term="301-work-blog" /><category term="301-work-learning" /><summary type="html"><![CDATA[Git rebase When to use If you want to have a clean git commits history. If six features are being developed in parallel, they starts from different time and they launch in different times. When you need to roll back some features, you will discover that you have diverged from the main so much. What is git rebase When you merge a branch, step 3 will actually look like this:]]></summary></entry><entry><title type="html">【Big-Data】Java Maven</title><link href="http://localhost:4000/work/maven/2022/10/24/maven.html" rel="alternate" type="text/html" title="【Big-Data】Java Maven" /><published>2022-10-24T09:18:07+08:00</published><updated>2022-10-24T09:18:07+08:00</updated><id>http://localhost:4000/work/maven/2022/10/24/maven</id><content type="html" xml:base="http://localhost:4000/work/maven/2022/10/24/maven.html"><![CDATA[<h1 id="maven详解">Maven详解</h1>

<h2 id="maven-archetype">Maven archetype</h2>

<p>可以理解为生成项目的template。在脚手架生成项目的时候使用的。</p>

<p>POM文件是Maven的入口文件，标签详解如下</p>

<!--more-->

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;project</span> <span class="na">xmlns=</span><span class="s">"http://maven.apache.org/POM/4.0.0"</span> <span class="na">xmlns:xsi=</span><span class="s">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="na">xsi:schemaLocation=</span><span class="s">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd"</span><span class="nt">&gt;</span>
    <span class="c">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 
        version。 --&gt;</span>
    <span class="nt">&lt;parent&gt;</span>
        <span class="c">&lt;!--被继承的父项目的构件标识符 --&gt;</span>
        <span class="nt">&lt;artifactId</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span>
        <span class="nt">&lt;groupId</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--被继承的父项目的版本 --&gt;</span>
        <span class="nt">&lt;version</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 
            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span>
        <span class="nt">&lt;relativePath</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/parent&gt;</span>
    <span class="c">&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span>
    <span class="nt">&lt;modelVersion&gt;</span>4.0.0<span class="nt">&lt;/modelVersion&gt;</span>
    <span class="c">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span>
    <span class="nt">&lt;groupId&gt;</span>asia.banseon<span class="nt">&lt;/groupId&gt;</span>
    <span class="c">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 
        特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;</span>
    <span class="nt">&lt;artifactId&gt;</span>banseon-maven2<span class="nt">&lt;/artifactId&gt;</span>
    <span class="c">&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span>
    <span class="nt">&lt;packaging&gt;</span>jar<span class="nt">&lt;/packaging&gt;</span>
    <span class="c">&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span>
    <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
    <span class="c">&lt;!--项目的名称, Maven产生的文档用 --&gt;</span>
    <span class="nt">&lt;name&gt;</span>banseon-maven<span class="nt">&lt;/name&gt;</span>
    <span class="c">&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span>
    <span class="nt">&lt;url&gt;</span>http://www.baidu.com/banseon<span class="nt">&lt;/url&gt;</span>
    <span class="c">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 
        签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span>
    <span class="nt">&lt;description&gt;</span>A maven project to study maven.<span class="nt">&lt;/description&gt;</span>
    <span class="c">&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span>
    <span class="nt">&lt;prerequisites&gt;</span>
        <span class="c">&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span>
        <span class="nt">&lt;maven</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/prerequisites&gt;</span>
    <span class="c">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span>
    <span class="nt">&lt;issueManagement&gt;</span>
        <span class="c">&lt;!--问题管理系统（例如jira）的名字， --&gt;</span>
        <span class="nt">&lt;system&gt;</span>jira<span class="nt">&lt;/system&gt;</span>
        <span class="c">&lt;!--该项目使用的问题管理系统的URL --&gt;</span>
        <span class="nt">&lt;url&gt;</span>http://jira.baidu.com/banseon<span class="nt">&lt;/url&gt;</span>
    <span class="nt">&lt;/issueManagement&gt;</span>
    <span class="c">&lt;!--项目持续集成信息 --&gt;</span>
    <span class="nt">&lt;ciManagement&gt;</span>
        <span class="c">&lt;!--持续集成系统的名字，例如continuum --&gt;</span>
        <span class="nt">&lt;system</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span>
        <span class="nt">&lt;url</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span>
        <span class="nt">&lt;notifiers&gt;</span>
            <span class="c">&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span>
            <span class="nt">&lt;notifier&gt;</span>
                <span class="c">&lt;!--传送通知的途径 --&gt;</span>
                <span class="nt">&lt;type</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--发生错误时是否通知 --&gt;</span>
                <span class="nt">&lt;sendOnError</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--构建失败时是否通知 --&gt;</span>
                <span class="nt">&lt;sendOnFailure</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--构建成功时是否通知 --&gt;</span>
                <span class="nt">&lt;sendOnSuccess</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--发生警告时是否通知 --&gt;</span>
                <span class="nt">&lt;sendOnWarning</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--不赞成使用。通知发送到哪里 --&gt;</span>
                <span class="nt">&lt;address</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--扩展配置项 --&gt;</span>
                <span class="nt">&lt;configuration</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/notifier&gt;</span>
        <span class="nt">&lt;/notifiers&gt;</span>
    <span class="nt">&lt;/ciManagement&gt;</span>
    <span class="c">&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span>
    <span class="nt">&lt;inceptionYear</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!--项目相关邮件列表信息 --&gt;</span>
    <span class="nt">&lt;mailingLists&gt;</span>
        <span class="c">&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span>
        <span class="nt">&lt;mailingList&gt;</span>
            <span class="c">&lt;!--邮件的名称 --&gt;</span>
            <span class="nt">&lt;name&gt;</span>Demo<span class="nt">&lt;/name&gt;</span>
            <span class="c">&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span>
            <span class="nt">&lt;post&gt;</span>banseon@126.com<span class="nt">&lt;/post&gt;</span>
            <span class="c">&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span>
            <span class="nt">&lt;subscribe&gt;</span>banseon@126.com<span class="nt">&lt;/subscribe&gt;</span>
            <span class="c">&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span>
            <span class="nt">&lt;unsubscribe&gt;</span>banseon@126.com<span class="nt">&lt;/unsubscribe&gt;</span>
            <span class="c">&lt;!--你可以浏览邮件信息的URL --&gt;</span>
            <span class="nt">&lt;archive&gt;</span>http:/hi.baidu.com/banseon/demo/dev/<span class="nt">&lt;/archive&gt;</span>
        <span class="nt">&lt;/mailingList&gt;</span>
    <span class="nt">&lt;/mailingLists&gt;</span>
    <span class="c">&lt;!--项目开发者列表 --&gt;</span>
    <span class="nt">&lt;developers&gt;</span>
        <span class="c">&lt;!--某个项目开发者的信息 --&gt;</span>
        <span class="nt">&lt;developer&gt;</span>
            <span class="c">&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span>
            <span class="nt">&lt;id&gt;</span>HELLO WORLD<span class="nt">&lt;/id&gt;</span>
            <span class="c">&lt;!--项目开发者的全名 --&gt;</span>
            <span class="nt">&lt;name&gt;</span>banseon<span class="nt">&lt;/name&gt;</span>
            <span class="c">&lt;!--项目开发者的email --&gt;</span>
            <span class="nt">&lt;email&gt;</span>banseon@126.com<span class="nt">&lt;/email&gt;</span>
            <span class="c">&lt;!--项目开发者的主页的URL --&gt;</span>
            <span class="nt">&lt;url</span> <span class="nt">/&gt;</span>
            <span class="c">&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span>
            <span class="nt">&lt;roles&gt;</span>
                <span class="nt">&lt;role&gt;</span>Project Manager<span class="nt">&lt;/role&gt;</span>
                <span class="nt">&lt;role&gt;</span>Architect<span class="nt">&lt;/role&gt;</span>
            <span class="nt">&lt;/roles&gt;</span>
            <span class="c">&lt;!--项目开发者所属组织 --&gt;</span>
            <span class="nt">&lt;organization&gt;</span>demo<span class="nt">&lt;/organization&gt;</span>
            <span class="c">&lt;!--项目开发者所属组织的URL --&gt;</span>
            <span class="nt">&lt;organizationUrl&gt;</span>http://hi.baidu.com/banseon<span class="nt">&lt;/organizationUrl&gt;</span>
            <span class="c">&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span>
            <span class="nt">&lt;properties&gt;</span>
                <span class="nt">&lt;dept&gt;</span>No<span class="nt">&lt;/dept&gt;</span>
            <span class="nt">&lt;/properties&gt;</span>
            <span class="c">&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span>
            <span class="nt">&lt;timezone&gt;</span>-5<span class="nt">&lt;/timezone&gt;</span>
        <span class="nt">&lt;/developer&gt;</span>
    <span class="nt">&lt;/developers&gt;</span>
    <span class="c">&lt;!--项目的其他贡献者列表 --&gt;</span>
    <span class="nt">&lt;contributors&gt;</span>
        <span class="c">&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span>
        <span class="nt">&lt;contributor&gt;</span>
            <span class="nt">&lt;name</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;email</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;url</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;organization</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;organizationUrl</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;roles</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;timezone</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;properties</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/contributor&gt;</span>
    <span class="nt">&lt;/contributors&gt;</span>
    <span class="c">&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span>
    <span class="nt">&lt;licenses&gt;</span>
        <span class="c">&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span>
        <span class="nt">&lt;license&gt;</span>
            <span class="c">&lt;!--license用于法律上的名称 --&gt;</span>
            <span class="nt">&lt;name&gt;</span>Apache 2<span class="nt">&lt;/name&gt;</span>
            <span class="c">&lt;!--官方的license正文页面的URL --&gt;</span>
            <span class="nt">&lt;url&gt;</span>http://www.baidu.com/banseon/LICENSE-2.0.txt<span class="nt">&lt;/url&gt;</span>
            <span class="c">&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span>
            <span class="nt">&lt;distribution&gt;</span>repo<span class="nt">&lt;/distribution&gt;</span>
            <span class="c">&lt;!--关于license的补充信息 --&gt;</span>
            <span class="nt">&lt;comments&gt;</span>A business-friendly OSS license<span class="nt">&lt;/comments&gt;</span>
        <span class="nt">&lt;/license&gt;</span>
    <span class="nt">&lt;/licenses&gt;</span>
    <span class="c">&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span>
    <span class="nt">&lt;scm&gt;</span>
        <span class="c">&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span>
        <span class="nt">&lt;connection&gt;</span>
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)
        <span class="nt">&lt;/connection&gt;</span>
        <span class="c">&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span>
        <span class="nt">&lt;developerConnection&gt;</span>
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk
        <span class="nt">&lt;/developerConnection&gt;</span>
        <span class="c">&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span>
        <span class="nt">&lt;tag</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span>
        <span class="nt">&lt;url&gt;</span>http://svn.baidu.com/banseon<span class="nt">&lt;/url&gt;</span>
    <span class="nt">&lt;/scm&gt;</span>
    <span class="c">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span>
    <span class="nt">&lt;organization&gt;</span>
        <span class="c">&lt;!--组织的全名 --&gt;</span>
        <span class="nt">&lt;name&gt;</span>demo<span class="nt">&lt;/name&gt;</span>
        <span class="c">&lt;!--组织主页的URL --&gt;</span>
        <span class="nt">&lt;url&gt;</span>http://www.baidu.com/banseon<span class="nt">&lt;/url&gt;</span>
    <span class="nt">&lt;/organization&gt;</span>
    <span class="c">&lt;!--构建项目需要的信息 --&gt;</span>
    <span class="nt">&lt;build&gt;</span>
        <span class="c">&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span>
        <span class="nt">&lt;sourceDirectory</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span>
        <span class="nt">&lt;scriptSourceDirectory</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span>
        <span class="nt">&lt;testSourceDirectory</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span>
        <span class="nt">&lt;outputDirectory</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span>
        <span class="nt">&lt;testOutputDirectory</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--使用来自该项目的一系列构建扩展 --&gt;</span>
        <span class="nt">&lt;extensions&gt;</span>
            <span class="c">&lt;!--描述使用到的构建扩展。 --&gt;</span>
            <span class="nt">&lt;extension&gt;</span>
                <span class="c">&lt;!--构建扩展的groupId --&gt;</span>
                <span class="nt">&lt;groupId</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--构建扩展的artifactId --&gt;</span>
                <span class="nt">&lt;artifactId</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--构建扩展的版本 --&gt;</span>
                <span class="nt">&lt;version</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/extension&gt;</span>
        <span class="nt">&lt;/extensions&gt;</span>
        <span class="c">&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span>
        <span class="nt">&lt;defaultGoal</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span>
        <span class="nt">&lt;resources&gt;</span>
            <span class="c">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span>
            <span class="nt">&lt;resource&gt;</span>
                <span class="c">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 
                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span>
                <span class="nt">&lt;targetPath</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span>
                <span class="nt">&lt;filtering</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span>
                <span class="nt">&lt;directory</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span>
                <span class="nt">&lt;includes</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--排除的模式列表，例如**/*.xml --&gt;</span>
                <span class="nt">&lt;excludes</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/resource&gt;</span>
        <span class="nt">&lt;/resources&gt;</span>
        <span class="c">&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span>
        <span class="nt">&lt;testResources&gt;</span>
            <span class="c">&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span>
            <span class="nt">&lt;testResource&gt;</span>
                <span class="nt">&lt;targetPath</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;filtering</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;directory</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;includes</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;excludes</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/testResource&gt;</span>
        <span class="nt">&lt;/testResources&gt;</span>
        <span class="c">&lt;!--构建产生的所有文件存放的目录 --&gt;</span>
        <span class="nt">&lt;directory</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。 --&gt;</span>
        <span class="nt">&lt;finalName</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span>
        <span class="nt">&lt;filters</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span>
        <span class="nt">&lt;pluginManagement&gt;</span>
            <span class="c">&lt;!--使用的插件列表 。 --&gt;</span>
            <span class="nt">&lt;plugins&gt;</span>
                <span class="c">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span>
                <span class="nt">&lt;plugin&gt;</span>
                    <span class="c">&lt;!--插件在仓库里的group ID --&gt;</span>
                    <span class="nt">&lt;groupId</span> <span class="nt">/&gt;</span>
                    <span class="c">&lt;!--插件在仓库里的artifact ID --&gt;</span>
                    <span class="nt">&lt;artifactId</span> <span class="nt">/&gt;</span>
                    <span class="c">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span>
                    <span class="nt">&lt;version</span> <span class="nt">/&gt;</span>
                    <span class="c">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span>
                    <span class="nt">&lt;extensions</span> <span class="nt">/&gt;</span>
                    <span class="c">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span>
                    <span class="nt">&lt;executions&gt;</span>
                        <span class="c">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span>
                        <span class="nt">&lt;execution&gt;</span>
                            <span class="c">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span>
                            <span class="nt">&lt;id</span> <span class="nt">/&gt;</span>
                            <span class="c">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span>
                            <span class="nt">&lt;phase</span> <span class="nt">/&gt;</span>
                            <span class="c">&lt;!--配置的执行目标 --&gt;</span>
                            <span class="nt">&lt;goals</span> <span class="nt">/&gt;</span>
                            <span class="c">&lt;!--配置是否被传播到子POM --&gt;</span>
                            <span class="nt">&lt;inherited</span> <span class="nt">/&gt;</span>
                            <span class="c">&lt;!--作为DOM对象的配置 --&gt;</span>
                            <span class="nt">&lt;configuration</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;/execution&gt;</span>
                    <span class="nt">&lt;/executions&gt;</span>
                    <span class="c">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span>
                    <span class="nt">&lt;dependencies&gt;</span>
                        <span class="c">&lt;!--参见dependencies/dependency元素 --&gt;</span>
                        <span class="nt">&lt;dependency&gt;</span>
                            ......
                        <span class="nt">&lt;/dependency&gt;</span>
                    <span class="nt">&lt;/dependencies&gt;</span>
                    <span class="c">&lt;!--任何配置是否被传播到子项目 --&gt;</span>
                    <span class="nt">&lt;inherited</span> <span class="nt">/&gt;</span>
                    <span class="c">&lt;!--作为DOM对象的配置 --&gt;</span>
                    <span class="nt">&lt;configuration</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;/plugin&gt;</span>
            <span class="nt">&lt;/plugins&gt;</span>
        <span class="nt">&lt;/pluginManagement&gt;</span>
        <span class="c">&lt;!--使用的插件列表 --&gt;</span>
        <span class="nt">&lt;plugins&gt;</span>
            <span class="c">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span>
            <span class="nt">&lt;plugin&gt;</span>
                <span class="nt">&lt;groupId</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;artifactId</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;version</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;extensions</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;executions&gt;</span>
                    <span class="nt">&lt;execution&gt;</span>
                        <span class="nt">&lt;id</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;phase</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;goals</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;inherited</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;configuration</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;/execution&gt;</span>
                <span class="nt">&lt;/executions&gt;</span>
                <span class="nt">&lt;dependencies&gt;</span>
                    <span class="c">&lt;!--参见dependencies/dependency元素 --&gt;</span>
                    <span class="nt">&lt;dependency&gt;</span>
                        ......
                    <span class="nt">&lt;/dependency&gt;</span>
                <span class="nt">&lt;/dependencies&gt;</span>
                <span class="nt">&lt;goals</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;inherited</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;configuration</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/plugin&gt;</span>
        <span class="nt">&lt;/plugins&gt;</span>
    <span class="nt">&lt;/build&gt;</span>
    <span class="c">&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span>
    <span class="nt">&lt;profiles&gt;</span>
        <span class="c">&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span>
        <span class="nt">&lt;profile&gt;</span>
            <span class="c">&lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span>
            <span class="nt">&lt;id</span> <span class="nt">/&gt;</span>
            <span class="c">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</span>
            <span class="nt">&lt;activation&gt;</span>
                <span class="c">&lt;!--profile默认是否激活的标志 --&gt;</span>
                <span class="nt">&lt;activeByDefault</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span>
                <span class="nt">&lt;jdk</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span>
                <span class="nt">&lt;os&gt;</span>
                    <span class="c">&lt;!--激活profile的操作系统的名字 --&gt;</span>
                    <span class="nt">&lt;name&gt;</span>Windows XP<span class="nt">&lt;/name&gt;</span>
                    <span class="c">&lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;</span>
                    <span class="nt">&lt;family&gt;</span>Windows<span class="nt">&lt;/family&gt;</span>
                    <span class="c">&lt;!--激活profile的操作系统体系结构 --&gt;</span>
                    <span class="nt">&lt;arch&gt;</span>x86<span class="nt">&lt;/arch&gt;</span>
                    <span class="c">&lt;!--激活profile的操作系统版本 --&gt;</span>
                    <span class="nt">&lt;version&gt;</span>5.1.2600<span class="nt">&lt;/version&gt;</span>
                <span class="nt">&lt;/os&gt;</span>
                <span class="c">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span>
                <span class="nt">&lt;property&gt;</span>
                    <span class="c">&lt;!--激活profile的属性的名称 --&gt;</span>
                    <span class="nt">&lt;name&gt;</span>mavenVersion<span class="nt">&lt;/name&gt;</span>
                    <span class="c">&lt;!--激活profile的属性的值 --&gt;</span>
                    <span class="nt">&lt;value&gt;</span>2.0.3<span class="nt">&lt;/value&gt;</span>
                <span class="nt">&lt;/property&gt;</span>
                <span class="c">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span>
                <span class="nt">&lt;file&gt;</span>
                    <span class="c">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span>
                    <span class="nt">&lt;exists&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/
                    <span class="nt">&lt;/exists&gt;</span>
                    <span class="c">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span>
                    <span class="nt">&lt;missing&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/
                    <span class="nt">&lt;/missing&gt;</span>
                <span class="nt">&lt;/file&gt;</span>
            <span class="nt">&lt;/activation&gt;</span>
            <span class="c">&lt;!--构建项目所需要的信息。参见build元素 --&gt;</span>
            <span class="nt">&lt;build&gt;</span>
                <span class="nt">&lt;defaultGoal</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;resources&gt;</span>
                    <span class="nt">&lt;resource&gt;</span>
                        <span class="nt">&lt;targetPath</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;filtering</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;directory</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;includes</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;excludes</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;/resource&gt;</span>
                <span class="nt">&lt;/resources&gt;</span>
                <span class="nt">&lt;testResources&gt;</span>
                    <span class="nt">&lt;testResource&gt;</span>
                        <span class="nt">&lt;targetPath</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;filtering</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;directory</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;includes</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;excludes</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;/testResource&gt;</span>
                <span class="nt">&lt;/testResources&gt;</span>
                <span class="nt">&lt;directory</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;finalName</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;filters</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;pluginManagement&gt;</span>
                    <span class="nt">&lt;plugins&gt;</span>
                        <span class="c">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span>
                        <span class="nt">&lt;plugin&gt;</span>
                            <span class="nt">&lt;groupId</span> <span class="nt">/&gt;</span>
                            <span class="nt">&lt;artifactId</span> <span class="nt">/&gt;</span>
                            <span class="nt">&lt;version</span> <span class="nt">/&gt;</span>
                            <span class="nt">&lt;extensions</span> <span class="nt">/&gt;</span>
                            <span class="nt">&lt;executions&gt;</span>
                                <span class="nt">&lt;execution&gt;</span>
                                    <span class="nt">&lt;id</span> <span class="nt">/&gt;</span>
                                    <span class="nt">&lt;phase</span> <span class="nt">/&gt;</span>
                                    <span class="nt">&lt;goals</span> <span class="nt">/&gt;</span>
                                    <span class="nt">&lt;inherited</span> <span class="nt">/&gt;</span>
                                    <span class="nt">&lt;configuration</span> <span class="nt">/&gt;</span>
                                <span class="nt">&lt;/execution&gt;</span>
                            <span class="nt">&lt;/executions&gt;</span>
                            <span class="nt">&lt;dependencies&gt;</span>
                                <span class="c">&lt;!--参见dependencies/dependency元素 --&gt;</span>
                                <span class="nt">&lt;dependency&gt;</span>
                                    ......
                                <span class="nt">&lt;/dependency&gt;</span>
                            <span class="nt">&lt;/dependencies&gt;</span>
                            <span class="nt">&lt;goals</span> <span class="nt">/&gt;</span>
                            <span class="nt">&lt;inherited</span> <span class="nt">/&gt;</span>
                            <span class="nt">&lt;configuration</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;/plugin&gt;</span>
                    <span class="nt">&lt;/plugins&gt;</span>
                <span class="nt">&lt;/pluginManagement&gt;</span>
                <span class="nt">&lt;plugins&gt;</span>
                    <span class="c">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span>
                    <span class="nt">&lt;plugin&gt;</span>
                        <span class="nt">&lt;groupId</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;artifactId</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;version</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;extensions</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;executions&gt;</span>
                            <span class="nt">&lt;execution&gt;</span>
                                <span class="nt">&lt;id</span> <span class="nt">/&gt;</span>
                                <span class="nt">&lt;phase</span> <span class="nt">/&gt;</span>
                                <span class="nt">&lt;goals</span> <span class="nt">/&gt;</span>
                                <span class="nt">&lt;inherited</span> <span class="nt">/&gt;</span>
                                <span class="nt">&lt;configuration</span> <span class="nt">/&gt;</span>
                            <span class="nt">&lt;/execution&gt;</span>
                        <span class="nt">&lt;/executions&gt;</span>
                        <span class="nt">&lt;dependencies&gt;</span>
                            <span class="c">&lt;!--参见dependencies/dependency元素 --&gt;</span>
                            <span class="nt">&lt;dependency&gt;</span>
                                ......
                            <span class="nt">&lt;/dependency&gt;</span>
                        <span class="nt">&lt;/dependencies&gt;</span>
                        <span class="nt">&lt;goals</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;inherited</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;configuration</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;/plugin&gt;</span>
                <span class="nt">&lt;/plugins&gt;</span>
            <span class="nt">&lt;/build&gt;</span>
            <span class="c">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span>
            <span class="nt">&lt;modules</span> <span class="nt">/&gt;</span>
            <span class="c">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span>
            <span class="nt">&lt;repositories&gt;</span>
                <span class="c">&lt;!--参见repositories/repository元素 --&gt;</span>
                <span class="nt">&lt;repository&gt;</span>
                    <span class="nt">&lt;releases&gt;</span>
                        <span class="nt">&lt;enabled</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;updatePolicy</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;checksumPolicy</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;/releases&gt;</span>
                    <span class="nt">&lt;snapshots&gt;</span>
                        <span class="nt">&lt;enabled</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;updatePolicy</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;checksumPolicy</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;/snapshots&gt;</span>
                    <span class="nt">&lt;id</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;name</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;url</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;layout</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;/repository&gt;</span>
            <span class="nt">&lt;/repositories&gt;</span>
            <span class="c">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span>
            <span class="nt">&lt;pluginRepositories&gt;</span>
                <span class="c">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span>
                <span class="nt">&lt;pluginRepository&gt;</span>
                    <span class="nt">&lt;releases&gt;</span>
                        <span class="nt">&lt;enabled</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;updatePolicy</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;checksumPolicy</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;/releases&gt;</span>
                    <span class="nt">&lt;snapshots&gt;</span>
                        <span class="nt">&lt;enabled</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;updatePolicy</span> <span class="nt">/&gt;</span>
                        <span class="nt">&lt;checksumPolicy</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;/snapshots&gt;</span>
                    <span class="nt">&lt;id</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;name</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;url</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;layout</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;/pluginRepository&gt;</span>
            <span class="nt">&lt;/pluginRepositories&gt;</span>
            <span class="c">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span>
            <span class="nt">&lt;dependencies&gt;</span>
                <span class="c">&lt;!--参见dependencies/dependency元素 --&gt;</span>
                <span class="nt">&lt;dependency&gt;</span>
                    ......
                <span class="nt">&lt;/dependency&gt;</span>
            <span class="nt">&lt;/dependencies&gt;</span>
            <span class="c">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span>
            <span class="nt">&lt;reports</span> <span class="nt">/&gt;</span>
            <span class="c">&lt;!--该元素包括使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span>
            <span class="nt">&lt;reporting&gt;</span>
                ......
            <span class="nt">&lt;/reporting&gt;</span>
            <span class="c">&lt;!--参见dependencyManagement元素 --&gt;</span>
            <span class="nt">&lt;dependencyManagement&gt;</span>
                <span class="nt">&lt;dependencies&gt;</span>
                    <span class="c">&lt;!--参见dependencies/dependency元素 --&gt;</span>
                    <span class="nt">&lt;dependency&gt;</span>
                        ......
                    <span class="nt">&lt;/dependency&gt;</span>
                <span class="nt">&lt;/dependencies&gt;</span>
            <span class="nt">&lt;/dependencyManagement&gt;</span>
            <span class="c">&lt;!--参见distributionManagement元素 --&gt;</span>
            <span class="nt">&lt;distributionManagement&gt;</span>
                ......
            <span class="nt">&lt;/distributionManagement&gt;</span>
            <span class="c">&lt;!--参见properties元素 --&gt;</span>
            <span class="nt">&lt;properties</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/profile&gt;</span>
    <span class="nt">&lt;/profiles&gt;</span>
    <span class="c">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span>
    <span class="nt">&lt;modules</span> <span class="nt">/&gt;</span>
    <span class="c">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span>
    <span class="nt">&lt;repositories&gt;</span>
        <span class="c">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span>
        <span class="nt">&lt;repository&gt;</span>
            <span class="c">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span>
            <span class="nt">&lt;releases&gt;</span>
                <span class="c">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span>
                <span class="nt">&lt;enabled</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span>
                <span class="nt">&lt;updatePolicy</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span>
                <span class="nt">&lt;checksumPolicy</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/releases&gt;</span>
            <span class="c">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 
                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span>
            <span class="nt">&lt;snapshots&gt;</span>
                <span class="nt">&lt;enabled</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;updatePolicy</span> <span class="nt">/&gt;</span>
                <span class="nt">&lt;checksumPolicy</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;/snapshots&gt;</span>
            <span class="c">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span>
            <span class="nt">&lt;id&gt;</span>banseon-repository-proxy<span class="nt">&lt;/id&gt;</span>
            <span class="c">&lt;!--远程仓库名称 --&gt;</span>
            <span class="nt">&lt;name&gt;</span>banseon-repository-proxy<span class="nt">&lt;/name&gt;</span>
            <span class="c">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span>
            <span class="nt">&lt;url&gt;</span>http://192.168.1.169:9999/repository/<span class="nt">&lt;/url&gt;</span>
            <span class="c">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 
                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span>
            <span class="nt">&lt;layout&gt;</span>default<span class="nt">&lt;/layout&gt;</span>
        <span class="nt">&lt;/repository&gt;</span>
    <span class="nt">&lt;/repositories&gt;</span>
    <span class="c">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span>
    <span class="nt">&lt;pluginRepositories&gt;</span>
        <span class="c">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span>
        <span class="nt">&lt;pluginRepository&gt;</span>
            ......
        <span class="nt">&lt;/pluginRepository&gt;</span>
    <span class="nt">&lt;/pluginRepositories&gt;</span>
 
 
    <span class="c">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span>
    <span class="nt">&lt;dependencies&gt;</span>
        <span class="nt">&lt;dependency&gt;</span>
            <span class="c">&lt;!--依赖的group ID --&gt;</span>
            <span class="nt">&lt;groupId&gt;</span>org.apache.maven<span class="nt">&lt;/groupId&gt;</span>
            <span class="c">&lt;!--依赖的artifact ID --&gt;</span>
            <span class="nt">&lt;artifactId&gt;</span>maven-artifact<span class="nt">&lt;/artifactId&gt;</span>
            <span class="c">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span>
            <span class="nt">&lt;version&gt;</span>3.8.1<span class="nt">&lt;/version&gt;</span>
            <span class="c">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 
                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span>
            <span class="nt">&lt;type&gt;</span>jar<span class="nt">&lt;/type&gt;</span>
            <span class="c">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 
                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span>
            <span class="nt">&lt;classifier&gt;&lt;/classifier&gt;</span>
            <span class="c">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath 
                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 
                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span>
            <span class="nt">&lt;scope&gt;</span>test<span class="nt">&lt;/scope&gt;</span>
            <span class="c">&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 --&gt;</span>
            <span class="nt">&lt;systemPath&gt;&lt;/systemPath&gt;</span>
            <span class="c">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span>
            <span class="nt">&lt;exclusions&gt;</span>
                <span class="nt">&lt;exclusion&gt;</span>
                    <span class="nt">&lt;artifactId&gt;</span>spring-core<span class="nt">&lt;/artifactId&gt;</span>
                    <span class="nt">&lt;groupId&gt;</span>org.springframework<span class="nt">&lt;/groupId&gt;</span>
                <span class="nt">&lt;/exclusion&gt;</span>
            <span class="nt">&lt;/exclusions&gt;</span>
            <span class="c">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span>
            <span class="nt">&lt;optional&gt;</span>true<span class="nt">&lt;/optional&gt;</span>
        <span class="nt">&lt;/dependency&gt;</span>
    <span class="nt">&lt;/dependencies&gt;</span>
    <span class="c">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span>
    <span class="nt">&lt;reports&gt;&lt;/reports&gt;</span>
    <span class="c">&lt;!--该元素描述使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span>
    <span class="nt">&lt;reporting&gt;</span>
        <span class="c">&lt;!--true，则，网站不包括默认的报表。这包括"项目信息"菜单中的报表。 --&gt;</span>
        <span class="nt">&lt;excludeDefaults</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 --&gt;</span>
        <span class="nt">&lt;outputDirectory</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--使用的报表插件和他们的配置。 --&gt;</span>
        <span class="nt">&lt;plugins&gt;</span>
            <span class="c">&lt;!--plugin元素包含描述报表插件需要的信息 --&gt;</span>
            <span class="nt">&lt;plugin&gt;</span>
                <span class="c">&lt;!--报表插件在仓库里的group ID --&gt;</span>
                <span class="nt">&lt;groupId</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--报表插件在仓库里的artifact ID --&gt;</span>
                <span class="nt">&lt;artifactId</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--被使用的报表插件的版本（或版本范围） --&gt;</span>
                <span class="nt">&lt;version</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--任何配置是否被传播到子项目 --&gt;</span>
                <span class="nt">&lt;inherited</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--报表插件的配置 --&gt;</span>
                <span class="nt">&lt;configuration</span> <span class="nt">/&gt;</span>
                <span class="c">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span>
                <span class="nt">&lt;reportSets&gt;</span>
                    <span class="c">&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span>
                    <span class="nt">&lt;reportSet&gt;</span>
                        <span class="c">&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span>
                        <span class="nt">&lt;id</span> <span class="nt">/&gt;</span>
                        <span class="c">&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span>
                        <span class="nt">&lt;configuration</span> <span class="nt">/&gt;</span>
                        <span class="c">&lt;!--配置是否被继承到子POMs --&gt;</span>
                        <span class="nt">&lt;inherited</span> <span class="nt">/&gt;</span>
                        <span class="c">&lt;!--这个集合里使用到哪些报表 --&gt;</span>
                        <span class="nt">&lt;reports</span> <span class="nt">/&gt;</span>
                    <span class="nt">&lt;/reportSet&gt;</span>
                <span class="nt">&lt;/reportSets&gt;</span>
            <span class="nt">&lt;/plugin&gt;</span>
        <span class="nt">&lt;/plugins&gt;</span>
    <span class="nt">&lt;/reporting&gt;</span>
    <span class="c">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact 
        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span>
    <span class="nt">&lt;dependencyManagement&gt;</span>
        <span class="nt">&lt;dependencies&gt;</span>
            <span class="c">&lt;!--参见dependencies/dependency元素 --&gt;</span>
            <span class="nt">&lt;dependency&gt;</span>
                ......
            <span class="nt">&lt;/dependency&gt;</span>
        <span class="nt">&lt;/dependencies&gt;</span>
    <span class="nt">&lt;/dependencyManagement&gt;</span>
    <span class="c">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span>
    <span class="nt">&lt;distributionManagement&gt;</span>
        <span class="c">&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span>
        <span class="nt">&lt;repository&gt;</span>
            <span class="c">&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span>
            <span class="nt">&lt;uniqueVersion</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;id&gt;</span>banseon-maven2<span class="nt">&lt;/id&gt;</span>
            <span class="nt">&lt;name&gt;</span>banseon maven2<span class="nt">&lt;/name&gt;</span>
            <span class="nt">&lt;url&gt;</span>file://${basedir}/target/deploy<span class="nt">&lt;/url&gt;</span>
            <span class="nt">&lt;layout</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/repository&gt;</span>
        <span class="c">&lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span>
        <span class="nt">&lt;snapshotRepository&gt;</span>
            <span class="nt">&lt;uniqueVersion</span> <span class="nt">/&gt;</span>
            <span class="nt">&lt;id&gt;</span>banseon-maven2<span class="nt">&lt;/id&gt;</span>
            <span class="nt">&lt;name&gt;</span>Banseon-maven2 Snapshot Repository<span class="nt">&lt;/name&gt;</span>
            <span class="nt">&lt;url&gt;</span>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot<span class="nt">&lt;/url&gt;</span>
            <span class="nt">&lt;layout</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/snapshotRepository&gt;</span>
        <span class="c">&lt;!--部署项目的网站需要的信息 --&gt;</span>
        <span class="nt">&lt;site&gt;</span>
            <span class="c">&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span>
            <span class="nt">&lt;id&gt;</span>banseon-site<span class="nt">&lt;/id&gt;</span>
            <span class="c">&lt;!--部署位置的名称 --&gt;</span>
            <span class="nt">&lt;name&gt;</span>business api website<span class="nt">&lt;/name&gt;</span>
            <span class="c">&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span>
            <span class="nt">&lt;url&gt;</span>
                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web
            <span class="nt">&lt;/url&gt;</span>
        <span class="nt">&lt;/site&gt;</span>
        <span class="c">&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span>
        <span class="nt">&lt;downloadUrl</span> <span class="nt">/&gt;</span>
        <span class="c">&lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span>
        <span class="nt">&lt;relocation&gt;</span>
            <span class="c">&lt;!--构件新的group ID --&gt;</span>
            <span class="nt">&lt;groupId</span> <span class="nt">/&gt;</span>
            <span class="c">&lt;!--构件新的artifact ID --&gt;</span>
            <span class="nt">&lt;artifactId</span> <span class="nt">/&gt;</span>
            <span class="c">&lt;!--构件新的版本号 --&gt;</span>
            <span class="nt">&lt;version</span> <span class="nt">/&gt;</span>
            <span class="c">&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span>
            <span class="nt">&lt;message</span> <span class="nt">/&gt;</span>
        <span class="nt">&lt;/relocation&gt;</span>
        <span class="c">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 
            Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;</span>
        <span class="nt">&lt;status</span> <span class="nt">/&gt;</span>
    <span class="nt">&lt;/distributionManagement&gt;</span>
    <span class="c">&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span>
    <span class="nt">&lt;properties</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/project&gt;</span>
</code></pre></div></div>

<p>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">节点</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">project</td>
      <td style="text-align: left">工程的根标签。</td>
    </tr>
    <tr>
      <td style="text-align: left">modelVersion</td>
      <td style="text-align: left">模型版本需要设置为 4.0。</td>
    </tr>
    <tr>
      <td style="text-align: left">groupId</td>
      <td style="text-align: left">这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。</td>
    </tr>
    <tr>
      <td style="text-align: left">artifactId</td>
      <td style="text-align: left">这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。</td>
    </tr>
    <tr>
      <td style="text-align: left">version</td>
      <td style="text-align: left">这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：<code class="language-plaintext highlighter-rouge">com.company.bank:consumer-banking:1.0 com.company.bank:consumer-banking:1.1</code></td>
    </tr>
  </tbody>
</table>]]></content><author><name>Chengru Song</name></author><category term="[&quot;work&quot;, &quot;maven&quot;]" /><category term="301-work-blog" /><category term="301-work-learning" /><summary type="html"><![CDATA[Maven详解 Maven archetype 可以理解为生成项目的template。在脚手架生成项目的时候使用的。 POM文件是Maven的入口文件，标签详解如下]]></summary></entry><entry><title type="html">【Big-Data】Flink开发总结</title><link href="http://localhost:4000/work/java/2022/10/24/big-data-flink.html" rel="alternate" type="text/html" title="【Big-Data】Flink开发总结" /><published>2022-10-24T09:18:07+08:00</published><updated>2022-10-24T09:18:07+08:00</updated><id>http://localhost:4000/work/java/2022/10/24/big-data-flink</id><content type="html" xml:base="http://localhost:4000/work/java/2022/10/24/big-data-flink.html"><![CDATA[<h1 id="flink开发java版">Flink开发（Java版）</h1>

<h2 id="11-data-conversion">1.1 Data Conversion</h2>

<p>Reference: <a href="https://blog.csdn.net/lxhandlbb/article/details/83304153">Flink DataStream /DataSet 与Table的互相转化_唐予之_的博客-CSDN博客</a></p>

<h3 id="111-imports">1.1.1 Imports</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.apache.flink.streaming.api.scala.</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.table.api.scala._</span>
<span class="kn">import</span> <span class="nn">org.apache.flink.api.scala._</span>
<span class="kn">import</span> <span class="nn">scala.collection.JavaConverters._</span>
</code></pre></div></div>

<h3 id="112-register-datastream-of-dataset-as-table">1.1.2 Register Datastream of DataSet as Table</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// get TableEnvironment</span>
<span class="c1">// registration of a DataSet is equivalent</span>
<span class="n">val</span> <span class="n">tableEnv</span> <span class="nc">TableEnvironment</span><span class="o">.</span><span class="na">getTableEnvironment</span><span class="o">(</span><span class="n">env</span><span class="o">)</span>
<span class="n">val</span> <span class="nl">stream:</span><span class="nc">Datastream</span><span class="o">[(</span><span class="nc">Long</span><span class="o">,</span><span class="nc">String</span><span class="o">)]=...</span>
<span class="c1">//register the Datastream as Table "myTable"with fields "fo","f1"</span>
<span class="n">tableEnv</span><span class="o">.</span><span class="na">registerDataStream</span><span class="o">(</span><span class="s">"myTable"</span><span class="o">,</span><span class="n">stream</span><span class="o">)</span>
<span class="c1">//register the Datastream as table "myTable2"with fields "myLong","mystring"</span>
<span class="n">tableEnv</span><span class="o">.</span><span class="na">registerDatastream</span><span class="o">(</span><span class="s">"myTable2"</span><span class="o">,</span><span class="n">stream</span><span class="o">,</span><span class="err">'</span><span class="n">myLong</span><span class="err">'</span><span class="o">,</span><span class="n">myString</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="113-convert-a-datastream-or-dataset-into-a-table">1.1.3 Convert a DataStream or Dataset into a Table</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//get TableEnvironment</span>
<span class="c1">//registration of a DataSet is equivalent</span>
<span class="n">val</span> <span class="n">tableEnv</span> <span class="nc">TableEnvironment</span><span class="o">.</span><span class="na">getTableEnvironment</span> <span class="o">(</span><span class="n">env</span><span class="o">)</span>
<span class="n">val</span> <span class="nl">stream:</span><span class="nc">Datastream</span><span class="o">[(</span><span class="nc">Long</span><span class="o">,</span><span class="nc">String</span><span class="o">)]=..</span>
<span class="c1">//convert the Datastream into a Table with default fields '_1,'_2</span>
<span class="n">val</span> <span class="nl">table1:</span><span class="nc">Table</span> <span class="n">tableEnv</span><span class="o">.</span><span class="na">fromDatastream</span><span class="o">(</span><span class="n">stream</span><span class="o">)</span>
<span class="c1">//convert the Datastream into a Table with fields 'myLong,'myString</span>
<span class="n">val</span> <span class="nl">table2:</span><span class="nc">Table</span> <span class="n">tableEnv</span><span class="o">.</span><span class="na">fromDataStream</span><span class="o">(</span><span class="n">stream</span><span class="o">,</span><span class="err">'</span><span class="n">myLong</span><span class="o">,</span><span class="err">'</span><span class="n">myString</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="114-convert-a-table-into-a-datastream">1.1.4 Convert a table into a DataStream</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//get TableEnvironment.</span>
<span class="c1">//registration of a DataSet is equivalent</span>
<span class="n">val</span> <span class="n">tableEnv</span> <span class="nc">TableEnvironment</span><span class="o">.</span><span class="na">getTableEnvironment</span><span class="o">(</span><span class="n">env</span><span class="o">)</span>
<span class="c1">//Table with two fields (String name,Integer age)</span>
<span class="n">val</span> <span class="nl">table:</span><span class="nc">Table</span> <span class="o">=..</span>
<span class="c1">//convert the Table into an append Datastream of Row</span>
<span class="n">val</span> <span class="nl">dsRow:</span><span class="nc">DataStream</span><span class="o">[</span><span class="nc">Row</span><span class="o">]</span><span class="n">tableEnv</span><span class="o">.</span><span class="na">toAppendStream</span><span class="o">[</span><span class="nc">Row</span><span class="o">](</span><span class="n">table</span><span class="o">)</span>
<span class="c1">//convert the Table into an append Datastream of Tuple2[String,Int]</span>
<span class="n">val</span> <span class="nl">dsTuple:</span><span class="nc">DataStream</span><span class="o">[(</span><span class="nc">String</span><span class="o">,</span><span class="nc">Int</span><span class="o">)]</span><span class="n">dsTuple</span>
<span class="n">tableEnv</span><span class="o">.</span><span class="na">toAppendstream</span><span class="o">[(</span><span class="nc">String</span><span class="o">,</span><span class="nc">Int</span><span class="o">)](</span><span class="n">table</span><span class="o">)</span>
<span class="c1">//convert the Table into a retract Datastream of Row.</span>
<span class="o">/</span><span class="mi">1</span>
<span class="c1">//A retract stream of type X is a Datastream[(Boolean,X)].</span>
<span class="c1">//</span>
<span class="c1">//The boolean field indicates the type of the change.</span>
<span class="c1">//</span>
<span class="c1">//True is INSERT,false is DELETE.</span>
<span class="n">val</span> <span class="nl">retractstream:</span><span class="nc">Datastream</span><span class="o">[(</span><span class="nc">Boolean</span><span class="o">,</span><span class="nc">Row</span><span class="o">)]=</span><span class="n">tableEnv</span><span class="o">.</span><span class="na">toRetractstream</span> <span class="o">[</span><span class="nc">Row</span><span class="o">](</span><span class="n">table</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="115-convert-table-into-a-dataset">1.1.5 Convert table into a DataSet</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//get TableEnvironment</span>
<span class="c1">//registration of a DataSet is equivalent</span>
<span class="n">val</span> <span class="n">tableEnv</span> <span class="o">=</span> <span class="nc">TableEnvironment</span><span class="o">.</span><span class="na">getTableEnvironment</span> <span class="o">(</span><span class="n">env</span><span class="o">)</span>
<span class="c1">//Table with two fields (String name,Integer age)</span>
<span class="n">val</span> <span class="nl">table:</span><span class="nc">Table</span> <span class="o">=..</span>
<span class="c1">//convert the Table into a DataSet of Row</span>
<span class="n">val</span> <span class="nl">dsRow:</span><span class="nc">DataSet</span><span class="o">[</span><span class="nc">Row</span><span class="o">]</span> <span class="o">=</span> <span class="n">tableEnv</span><span class="o">.</span><span class="na">toDataSet</span> <span class="o">[</span><span class="nc">Row</span><span class="o">](</span><span class="n">table</span><span class="o">)</span>
<span class="c1">//convert the Table into a DataSet of Tuple2[String,Int]</span>
<span class="n">val</span> <span class="nl">dsTuple:</span><span class="nc">DataSet</span><span class="o">[(</span><span class="nc">String</span><span class="o">,</span><span class="nc">Int</span><span class="o">)]=</span><span class="n">tableEnv</span><span class="o">.</span><span class="na">toDataSet</span><span class="o">[(</span><span class="nc">String</span><span class="o">,</span><span class="nc">Int</span><span class="o">)](</span><span class="n">table</span><span class="o">)</span>
</code></pre></div></div>]]></content><author><name>Chengru Song</name></author><category term="[&quot;work&quot;, &quot;java&quot;]" /><category term="301-work-blog" /><category term="301-work-learning" /><summary type="html"><![CDATA[Flink开发（Java版） 1.1 Data Conversion Reference: Flink DataStream /DataSet 与Table的互相转化_唐予之_的博客-CSDN博客 1.1.1 Imports import org.apache.flink.streaming.api.scala. import org.apache.flink.table.api.scala._ import org.apache.flink.api.scala._ import scala.collection.JavaConverters._ 1.1.2 Register Datastream of DataSet as Table // get TableEnvironment // registration of a DataSet is equivalent val tableEnv TableEnvironment.getTableEnvironment(env) val stream:Datastream[(Long,String)]=... //register the Datastream as Table "myTable"with fields "fo","f1" tableEnv.registerDataStream("myTable",stream) //register the Datastream as table "myTable2"with fields "myLong","mystring" tableEnv.registerDatastream("myTable2",stream,'myLong',myString) 1.1.3 Convert a DataStream or Dataset into a Table //get TableEnvironment //registration of a DataSet is equivalent val tableEnv TableEnvironment.getTableEnvironment (env) val stream:Datastream[(Long,String)]=.. //convert the Datastream into a Table with default fields '_1,'_2 val table1:Table tableEnv.fromDatastream(stream) //convert the Datastream into a Table with fields 'myLong,'myString val table2:Table tableEnv.fromDataStream(stream,'myLong,'myString) 1.1.4 Convert a table into a DataStream //get TableEnvironment. //registration of a DataSet is equivalent val tableEnv TableEnvironment.getTableEnvironment(env) //Table with two fields (String name,Integer age) val table:Table =.. //convert the Table into an append Datastream of Row val dsRow:DataStream[Row]tableEnv.toAppendStream[Row](table) //convert the Table into an append Datastream of Tuple2[String,Int] val dsTuple:DataStream[(String,Int)]dsTuple tableEnv.toAppendstream[(String,Int)](table) //convert the Table into a retract Datastream of Row. /1 //A retract stream of type X is a Datastream[(Boolean,X)]. // //The boolean field indicates the type of the change. // //True is INSERT,false is DELETE. val retractstream:Datastream[(Boolean,Row)]=tableEnv.toRetractstream [Row](table) 1.1.5 Convert table into a DataSet //get TableEnvironment //registration of a DataSet is equivalent val tableEnv = TableEnvironment.getTableEnvironment (env) //Table with two fields (String name,Integer age) val table:Table =.. //convert the Table into a DataSet of Row val dsRow:DataSet[Row] = tableEnv.toDataSet [Row](table) //convert the Table into a DataSet of Tuple2[String,Int] val dsTuple:DataSet[(String,Int)]=tableEnv.toDataSet[(String,Int)](table)]]></summary></entry></feed>